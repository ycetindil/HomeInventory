# Home Inventory App — Architecture (Living Document)

> **Purpose:** Build an iPhone-first, visual-first home inventory app (room photo -> tap hotspots -> item details & docs).
> Designed to later support family sharing and/or a web interface **without locking data into Apple-only storage types**.

---

## Status (as of Dec 27, 2025)
- Xcode project created with **Storage: None** (no SwiftData/Core Data generated by template).
- Current slice implemented:
  - Domain: `Location`, `LocationType`
  - Data: `InMemoryInventoryRepository` (seeded)
  - UI: `ContentView` + `LocationTreeView` (+ optional `LocationListView`)
  - State: `LocationsViewModel` (`@Observable`)
  - Tree rows show a **child-count indicator** for each node.

---

## UX & Strategy Principles (New)
*Integrated feedback from project start:*

1. **The "Quick Add" Rule**
   - **Problem:** Separating "Item Type" (metadata) from "Item Instance" (physical object) is architecturally correct but tedious for unique items.
   - **Solution:** We must build a "Quick Add" flow that creates both Type + Instance in one step for unique items (e.g., "Vintage Vase").
   - **Goal:** Avoid the "filling out tax forms" feeling.

2. **Visual Map Strategy**
   - **Challenge:** Precise polygon hotspots are hard to edit on a phone.
   - **MVP Approach:** Start with "Center Point + Radius" (circles) for hotspots. It is easier to tap and faster to edit.

3. **"No Storage" is a Feature**
   - **Strategy:** Keep `InMemoryInventoryRepository` available forever.
   - **Why:** It is essential for SwiftUI Previews, Unit Tests, and "Demo Mode" without corrupting real data. Do not delete it when we add Core Data.

4. **File Management**
   - **Reality:** Photos and PDFs will grow large.
   - **Plan:** Local-first storage (app sandbox) is fine for MVP, but the "Export" feature (JSON + Attachments ZIP) is critical for backup and migration.

---

## Non-negotiable guardrails (do not violate)
1. **UI must not depend on persistence types**
   - No `NSManagedObject`, `SwiftData` models, or DB DTOs in SwiftUI views.
   - Views consume **domain structs** only.
2. **Stable IDs everywhere**
   - Every entity has `id: UUID`.
   - Never use names/paths as identifiers.
3. **Timestamps + soft delete**
   - Every entity has: `createdAt`, `updatedAt`, `deletedAt: Date?`.
   - Prefer tombstones over hard-delete.
4. **No structure in strings**
   - No `"Kitchen/Cabinet A/Drawer 2"` stored as a single string field.
   - No `"ID1;ID2"` relationship lists in a single field.
5. **Locations are a tree**
   - Hierarchy defined by `parentId`.
6. **Relationships are first-class**
   - Use a `Relationship` entity/table with typed edges.
7. **Attachments are first-class**
   - Files stored in app sandbox; DB stores metadata + file reference.
   - Attachment links to an owner via `(ownerType, ownerId)`.
8. **Room maps are images + hotspots**
   - Hotspot geometry stored in **normalized coordinates (0–1)**.
   - Hotspots reference targets by `(targetType, targetId)`.
   - Map images are versioned.
9. **Sync boundary from day 1**
   - Define `SyncEngine` protocol early.
   - Start with `NoSyncEngine` implementation.
10. **Export/Import planned early**
    - Canonical portable format: **JSON manifest + ZIP attachments**.
    - Enables future Android/web and open-source handoff.

---

## High-level architecture (3 layers)
### 1) Domain layer (platform-neutral)
- Pure Swift structs + business rules.
- No Core Data, no SwiftUI, no file IO.

### 2) Data layer (replaceable)
- `InventoryRepository` for CRUD/query/search.
- `AttachmentStore` for file IO and `AssetRef`.
- `SyncEngine` for future syncing.

### 3) UI layer (SwiftUI)
- ViewModels call repository interfaces.
- Views present domain structs.

---

## Domain models (shape is stable; fields may grow)
### Location
- `id: UUID`
- `parentId: UUID?`
- `name: String`
- `type: LocationType` (House, Room, Cabinet, Drawer, Bin, Shelf, Zone…)
- `sortOrder: Int`
- `primaryMapImageId: UUID?`
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### MapImage
- `id: UUID`
- `locationId: UUID`
- `assetRef: AssetRef`
- `version: Int`
- `createdAt, updatedAt, deletedAt?`

### Hotspot
- `id: UUID`
- `mapImageId: UUID`
- `targetType: HotspotTargetType` (ItemInstance, MaterialSystem, Location)
- `targetId: UUID`
- `shape: HotspotShape` (circle/rect/polygon)
- `geometry: NormalizedGeometry` (0–1)
- `label: String?`
- `isHiddenInFamilyMode: Bool`
- `createdAt, updatedAt, deletedAt?`

### ItemType (model/product)
- `id: UUID`
- `name: String`
- `category: String`
- `brand: String?`
- `model: String?`
- `defaultAttributes: [String: AttributeValue]`
- `createdAt, updatedAt, deletedAt?`

### ItemInstance (physical unit)
- `id: UUID`
- `typeId: UUID`
- `displayName: String`
- `locationId: UUID?`
- `status: LifecycleStatus`
- `purchase: PurchaseInfo?`
- `identifiers: Identifiers` (serial, MAC, DSK, etc.)
- `attributes: [UUID: AttributeValue]`
- `disposition: DispositionInfo?`
- `createdAt, updatedAt, deletedAt?`

### MaterialSystem (coverage-based)
- `id: UUID`
- `class: CoverageClass` (Material/System)
- `name: String`
- `brandModel: String?`
- `coverageLocationIds: [UUID]` (or join table later)
- `install: InstallInfo?`
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### Relationship
- `id: UUID`
- `fromKind: RelationshipEndpointKind` (Type or Instance)
- `fromId: UUID`
- `toKind: RelationshipEndpointKind` (Type or Instance)
- `toId: UUID`
- `type: RelationshipType` (ConsumableFor, AccessoryFor, CompatibleWith, ReplacedBy, PartOf, Controls, PoweredBy…)
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### Attachment
- `id: UUID`
- `ownerType: AttachmentOwnerType` (ItemType, ItemInstance, MaterialSystem, Location)
- `ownerId: UUID`
- `kind: AttachmentKind` (Manual, Receipt, Warranty, Photo, Note, Other)
- `assetRef: AssetRef`
- `originalFilename: String?`
- `createdAt, updatedAt, deletedAt?`

---

## Data layer interfaces (contracts)
### InventoryRepository
Responsibilities:
- CRUD for all entities
- Query helpers:
  - by location subtree
  - by status
  - by type
- Basic search (v1)

### AttachmentStore
Responsibilities:
- Save files (PDF/photo) -> returns AssetRef
- Load by AssetRef
- Delete/purge assets (respect tombstones)

### SyncEngine
Responsibilities:
- Pull/push change sets (future)
- Conflict resolution (future)
- v1: NoSyncEngine stub

---

## Repository structure (recommended)
```text
HomeInventory/
  HomeInventoryApp/ # SwiftUI app target
  UI/
  ViewModels/
  HomeInventoryDomain/ # Domain structs + enums (no SwiftUI)
  HomeInventoryData/ # Repository impls, storage, file IO
  Docs/
    ARCHITECTURE.md
    STATUS.md
