# ARCHITECTURE.md
# Home Inventory App — Architecture (Living Document)

> **Purpose:** Build an iPhone-first, visual-first home inventory app (room photo → tap hotspots → item details & docs).  
> Designed to later support family sharing and/or a web interface **without locking data into Apple-only storage types**.

---

## Status (as of Dec 27, 2025)

- Xcode project created with **Storage: None** (no SwiftData/Core Data generated by template).
- Current slice implemented:
  - Domain: `Location`, `LocationType`
  - Data: `InMemoryInventoryRepository` (seeded)
  - UI: `ContentView` + `LocationTreeView` (+ optional `LocationListView`)
  - State: `LocationsViewModel` (`@Observable`)
  - Tree rows show a **child-count indicator** for each node.

---

## Non-negotiable guardrails (do not violate)

1. **UI must not depend on persistence types**
   - No `NSManagedObject`, `SwiftData` models, or DB DTOs in SwiftUI views.
   - Views consume **domain structs** only.

2. **Stable IDs everywhere**
   - Every entity has `id: UUID`.
   - Never use names/paths as identifiers.

3. **Timestamps + soft delete**
   - Every entity has: `createdAt`, `updatedAt`, `deletedAt: Date?`.
   - Prefer tombstones over hard-delete.

4. **No structure in strings**
   - No `"Kitchen/Cabinet A/Drawer 2"` stored as a single string field.
   - No `"ID1;ID2"` relationship lists in a single field.

5. **Locations are a tree**
   - Hierarchy defined by `parentId`.

6. **Relationships are first-class**
   - Use a `Relationship` entity/table with typed edges.

7. **Attachments are first-class**
   - Files stored in app sandbox; DB stores metadata + file reference.
   - Attachment links to an owner via `(ownerType, ownerId)`.

8. **Room maps are images + hotspots**
   - Hotspot geometry stored in **normalized coordinates (0–1)**.
   - Hotspots reference targets by `(targetType, targetId)`.
   - Map images are versioned.

9. **Sync boundary from day 1**
   - Define `SyncEngine` protocol early.
   - Start with `NoSyncEngine` implementation.

10. **Export/Import planned early**
   - Canonical portable format: **JSON manifest + ZIP attachments**.
   - Enables future Android/web and open-source handoff.

---

## High-level architecture (3 layers)

### 1) Domain layer (platform-neutral)
- Pure Swift structs + business rules.
- No Core Data, no SwiftUI, no file IO.

### 2) Data layer (replaceable)
- `InventoryRepository` for CRUD/query/search.
- `AttachmentStore` for file IO and `AssetRef`.
- `SyncEngine` for future syncing.

### 3) UI layer (SwiftUI)
- ViewModels call repository interfaces.
- Views present domain structs.

---

## Domain models (shape is stable; fields may grow)

### Location
- `id: UUID`
- `parentId: UUID?`
- `name: String`
- `type: LocationType` (House, Room, Cabinet, Drawer, Bin, Shelf, Zone…)
- `sortOrder: Int`
- `primaryMapImageId: UUID?`
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### MapImage
- `id: UUID`
- `locationId: UUID`
- `assetRef: AssetRef`
- `version: Int`
- `createdAt, updatedAt, deletedAt?`

### Hotspot
- `id: UUID`
- `mapImageId: UUID`
- `targetType: HotspotTargetType` (ItemInstance, MaterialSystem, Location)
- `targetId: UUID`
- `shape: HotspotShape` (circle/rect/polygon)
- `geometry: NormalizedGeometry` (0–1)
- `label: String?`
- `isHiddenInFamilyMode: Bool`
- `createdAt, updatedAt, deletedAt?`

### ItemType (model/product)
- `id: UUID`
- `name: String`
- `category: String`
- `brand: String?`
- `model: String?`
- `defaultAttributes: [String: AttributeValue]`
- `createdAt, updatedAt, deletedAt?`

### ItemInstance (physical unit)
- `id: UUID`
- `typeId: UUID`
- `displayName: String`
- `locationId: UUID?`
- `status: LifecycleStatus`
- `purchase: PurchaseInfo?`
- `identifiers: Identifiers` (serial, MAC, DSK, etc.)
- `attributes: [UUID: AttributeValue]`
- `disposition: DispositionInfo?`
- `createdAt, updatedAt, deletedAt?`

### MaterialSystem (coverage-based)
- `id: UUID`
- `class: CoverageClass` (Material/System)
- `name: String`
- `brandModel: String?`
- `coverageLocationIds: [UUID]` (or join table later)
- `install: InstallInfo?`
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### Relationship
- `id: UUID`
- `fromKind: RelationshipEndpointKind` (Type or Instance)
- `fromId: UUID`
- `toKind: RelationshipEndpointKind` (Type or Instance)
- `toId: UUID`
- `type: RelationshipType` (ConsumableFor, AccessoryFor, CompatibleWith, ReplacedBy, PartOf, Controls, PoweredBy…)
- `notes: String?`
- `createdAt, updatedAt, deletedAt?`

### Attachment
- `id: UUID`
- `ownerType: AttachmentOwnerType` (ItemType, ItemInstance, MaterialSystem, Location)
- `ownerId: UUID`
- `kind: AttachmentKind` (Manual, Receipt, Warranty, Photo, Note, Other)
- `assetRef: AssetRef`
- `originalFilename: String?`
- `createdAt, updatedAt, deletedAt?`

---

## Supporting types

### AssetRef
Storage abstraction so the domain model doesn’t care where the file lives.
- v1: relative path under app sandbox
- later: remote URL / blob key

### NormalizedGeometry
- Stored relative to the image (0–1)
- Keeps hotspots stable across device sizes and scaling

---

## Data layer interfaces (contracts)

### InventoryRepository
Responsibilities:
- CRUD for all entities
- Query helpers:
  - by location subtree
  - by status
  - by type
- Basic search (v1)

### AttachmentStore
Responsibilities:
- Save files (PDF/photo) → returns `AssetRef`
- Load by `AssetRef`
- Delete/purge assets (respect tombstones)

### SyncEngine
Responsibilities:
- Pull/push change sets (future)
- Conflict resolution (future)
- v1: `NoSyncEngine` stub

---

## UI principles

- Two modes:
  - **Family Mode**: browse/tap/search
  - **Admin Mode**: edit/add/move hotspots
- Home screen is the **Room Map**: photo + hotspots
- “Inbox” for unassigned scans/PDFs/photos

---

## Export/Import

Portable bundle:
- `manifest.json` (all entities)
- `attachments/` (binary files)
- zipped as `HomeInventoryExport_YYYYMMDD.zip`

---

## Source control workflow (non-negotiable)

We keep the repo continuously “commit-ready” so progress is never lost.

- **Commit at each milestone** (even small):
  - project created / builds
  - domain model changes
  - repository/view model wiring
  - docs updates (ARCHITECTURE.md, STATUS.md)

- **Docs are part of the system**
  - Any architectural decision or guardrail change must be committed **with** the code that implements it.

- **Green build rule**
  - Only commit when `⌘B` succeeds (unless we’re intentionally committing a broken state, which we avoid).

- **Keep the repo clean**
  - Don’t commit user/machine state (e.g. `xcuserdata/`, `DerivedData/`, `.DS_Store`).

- **Commit messages**
  - Prefer: `Area: short summary` (examples: `Domain: add LocationType`, `UI: wire LocationsViewModel`).
